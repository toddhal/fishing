<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fishing Frenzy - Catch 'em All!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #87CEEB 0%, #1E90FF 50%, #006994 100%);
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            cursor: pointer;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 18px;
            z-index: 10;
        }

        #ui div {
            margin: 5px 0;
        }

        #rodDisplay {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rod-icon {
            width: 30px;
            height: 6px;
            border-radius: 3px;
            display: inline-block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #shopBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            font-size: 18px;
            background: linear-gradient(180deg, #FFD700, #FFA500);
            border: 3px solid #8B4513;
            border-radius: 10px;
            cursor: pointer;
            color: #8B4513;
            font-weight: bold;
            z-index: 10;
            transition: transform 0.1s;
        }

        #shopBtn:hover {
            transform: scale(1.1);
        }

        #shop {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #8B4513, #654321);
            border: 5px solid #FFD700;
            border-radius: 20px;
            padding: 30px;
            color: white;
            z-index: 100;
            min-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #shop h2 {
            text-align: center;
            color: #FFD700;
            margin-bottom: 20px;
        }

        .upgrade {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .upgrade button {
            padding: 8px 15px;
            background: linear-gradient(180deg, #4CAF50, #2E7D32);
            border: 2px solid #1B5E20;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .upgrade button:disabled {
            background: #666;
            border-color: #444;
            cursor: not-allowed;
        }

        #closeShop {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: #c0392b;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
        }

        #castPower {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            display: none;
        }

        #castPowerFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.05s;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 16px;
            text-align: center;
            z-index: 10;
        }

        .fish-caught {
            position: absolute;
            font-size: 24px;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            z-index: 60;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(1.5); }
        }

        .coin-popup {
            position: absolute;
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: coinFloat 1.5s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 60;
        }

        @keyframes coinFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-60px); }
        }

        #collection {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #1a3a5c, #0d2137);
            border: 5px solid #4fc3f7;
            border-radius: 20px;
            padding: 30px;
            color: white;
            z-index: 100;
            min-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #collection h2 {
            text-align: center;
            color: #4fc3f7;
            margin-bottom: 20px;
        }

        .fish-entry {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .fish-entry.locked {
            opacity: 0.4;
        }

        .fish-entry.night-fish {
            border-left: 3px solid #9b59b6;
        }

        .fish-icon {
            font-size: 30px;
            margin-right: 15px;
        }

        #collectionBtn {
            position: absolute;
            top: 10px;
            right: 120px;
            padding: 10px 20px;
            font-size: 18px;
            background: linear-gradient(180deg, #4fc3f7, #0288d1);
            border: 3px solid #01579b;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            z-index: 10;
            transition: transform 0.1s;
        }

        #collectionBtn:hover {
            transform: scale(1.1);
        }

        #closeCollection {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: #c0392b;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        /* Reeling Mini-game UI */
        #reelGame {
            display: none;
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 15px;
            z-index: 80;
        }

        #reelGame h3 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        #tensionBar {
            width: 100%;
            height: 30px;
            background: linear-gradient(90deg, #27ae60 0%, #27ae60 30%, #f1c40f 30%, #f1c40f 70%, #e74c3c 70%, #e74c3c 100%);
            border-radius: 5px;
            position: relative;
            margin-bottom: 10px;
        }

        #tensionMarker {
            position: absolute;
            width: 8px;
            height: 40px;
            background: white;
            border: 2px solid #333;
            border-radius: 4px;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.05s;
        }

        #reelProgress {
            width: 100%;
            height: 15px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
        }

        #reelProgressFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.1s;
        }

        #fishStruggle {
            text-align: center;
            color: #f39c12;
            font-size: 12px;
            margin-top: 5px;
        }

        /* Time indicator */
        #timeIndicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="ui">
            <div>ü™ô Coins: <span id="coins">0</span></div>
            <div>üé£ Level: <span id="level">1</span></div>
            <div>‚≠ê XP: <span id="xp">0</span>/<span id="xpNeeded">100</span></div>
            <div>üêü Fish Caught: <span id="totalFish">0</span></div>
            <div id="rodDisplay">üé£ Rod: <span class="rod-icon" id="rodIcon"></span> <span id="rodName">Wood</span></div>
        </div>

        <div id="timeIndicator">‚òÄÔ∏è Day</div>

        <button id="collectionBtn">üìö Collection</button>
        <button id="shopBtn">üõí Shop</button>

        <div id="castPower">
            <div id="castPowerFill"></div>
        </div>

        <div id="message"></div>

        <div id="instructions">Hold SPACE or CLICK to charge cast, release to fish!</div>

        <!-- Reeling Mini-game -->
        <div id="reelGame">
            <h3>üé£ Keep the marker in the GREEN zone! Hold SPACE/Click to reel!</h3>
            <div id="tensionBar">
                <div id="tensionMarker"></div>
            </div>
            <div id="reelProgress">
                <div id="reelProgressFill"></div>
            </div>
            <div id="fishStruggle">The fish is calm...</div>
        </div>

        <div id="shop">
            <h2>üõí Upgrade Shop</h2>
            <div class="upgrade">
                <div>
                    <strong>üé£ Better Rod</strong><br>
                    <small>Faster fish attraction + Better rods!</small><br>
                    <small>Level: <span id="rodLevel">1</span>/10</small>
                </div>
                <button id="buyRod">100 ü™ô</button>
            </div>
            <div class="upgrade">
                <div>
                    <strong>ü™± Premium Bait</strong><br>
                    <small>Attract rarer fish</small><br>
                    <small>Level: <span id="baitLevel">1</span>/10</small>
                </div>
                <button id="buyBait">150 ü™ô</button>
            </div>
            <div class="upgrade">
                <div>
                    <strong>üßµ Strong Line</strong><br>
                    <small>Catch bigger fish + easier reeling</small><br>
                    <small>Level: <span id="lineLevel">1</span>/10</small>
                </div>
                <button id="buyLine">200 ü™ô</button>
            </div>
            <div class="upgrade">
                <div>
                    <strong>üçÄ Lucky Charm</strong><br>
                    <small>More bonus rewards</small><br>
                    <small>Level: <span id="luckLevel">1</span>/10</small>
                </div>
                <button id="buyLuck">250 ü™ô</button>
            </div>
            <button id="closeShop">Close</button>
        </div>

        <div id="collection">
            <h2>üìö Fish Collection</h2>
            <div id="fishList"></div>
            <button id="closeCollection">Close</button>
        </div>
    </div>

    <script>
        // Game Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Audio Context for sounds
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
        }

        function playSound(freq, duration, type = 'sine', volume = 0.3) {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.frequency.value = freq;
                oscillator.type = type;
                gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + duration);
            } catch (e) {}
        }

        function playCastSound() {
            playSound(200, 0.1, 'sine');
            setTimeout(() => playSound(150, 0.2, 'sine'), 100);
        }

        function playSplashSound() {
            // Create white noise for splash
            for (let i = 0; i < 5; i++) {
                setTimeout(() => playSound(80 + Math.random() * 60, 0.15, 'triangle', 0.15), i * 40);
            }
        }

        function playBiteSound() {
            playSound(800, 0.1, 'square', 0.2);
            setTimeout(() => playSound(1000, 0.1, 'square', 0.2), 50);
        }

        function playCatchSound(value) {
            const baseFreq = 400 + Math.min(value, 100) * 5;
            playSound(baseFreq, 0.15, 'sine');
            setTimeout(() => playSound(baseFreq * 1.25, 0.15, 'sine'), 100);
            setTimeout(() => playSound(baseFreq * 1.5, 0.2, 'sine'), 200);
        }

        function playLevelUpSound() {
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                setTimeout(() => playSound(freq, 0.3, 'sine', 0.4), i * 150);
            });
        }

        function playMissSound() {
            playSound(200, 0.2, 'sawtooth', 0.2);
            setTimeout(() => playSound(150, 0.3, 'sawtooth', 0.2), 100);
        }

        function playReelSound() {
            playSound(300 + Math.random() * 100, 0.05, 'square', 0.1);
        }

        function playSnapSound() {
            playSound(150, 0.3, 'sawtooth', 0.3);
            playSound(100, 0.4, 'sawtooth', 0.2);
        }

        // Rod Types - based on rod upgrade level
        const rodTypes = [
            { name: 'Wood', color: '#8B4513', gradient: ['#A0522D', '#654321'], minLevel: 1 },
            { name: 'Plastic', color: '#4A90D9', gradient: ['#5DADE2', '#2874A6'], minLevel: 3 },
            { name: 'Bronze', color: '#CD7F32', gradient: ['#DAA520', '#8B6914'], minLevel: 5 },
            { name: 'Silver', color: '#C0C0C0', gradient: ['#E8E8E8', '#A0A0A0'], minLevel: 7 },
            { name: 'Gold', color: '#FFD700', gradient: ['#FFE55C', '#DAA520'], minLevel: 9 },
            { name: 'Diamond', color: '#00FFFF', gradient: ['#E0FFFF', '#00CED1'], minLevel: 10, sparkle: true }
        ];

        function getCurrentRod() {
            const level = gameState.upgrades.rod;
            for (let i = rodTypes.length - 1; i >= 0; i--) {
                if (level >= rodTypes[i].minLevel) return rodTypes[i];
            }
            return rodTypes[0];
        }

        // Day/Night Fish Types
        const dayFishTypes = [
            { name: 'Sardine', emoji: 'üêü', value: 5, xp: 10, rarity: 1, minLine: 1, weight: 40, difficulty: 1 },
            { name: 'Mackerel', emoji: 'üê†', value: 10, xp: 20, rarity: 1, minLine: 1, weight: 30, difficulty: 1 },
            { name: 'Bass', emoji: 'üê°', value: 20, xp: 35, rarity: 2, minLine: 1, weight: 20, difficulty: 2 },
            { name: 'Salmon', emoji: 'üêü', value: 35, xp: 50, rarity: 2, minLine: 2, weight: 15, difficulty: 2 },
            { name: 'Tuna', emoji: 'üê†', value: 50, xp: 75, rarity: 3, minLine: 2, weight: 10, difficulty: 3 },
            { name: 'Swordfish', emoji: 'üó°Ô∏è', value: 75, xp: 100, rarity: 3, minLine: 3, weight: 7, difficulty: 4 },
            { name: 'Octopus', emoji: 'üêô', value: 100, xp: 150, rarity: 4, minLine: 3, weight: 5, difficulty: 4 },
            { name: 'Shark', emoji: 'ü¶à', value: 150, xp: 200, rarity: 4, minLine: 4, weight: 3, difficulty: 5 },
            { name: 'Whale', emoji: 'üêã', value: 250, xp: 350, rarity: 5, minLine: 5, weight: 1.5, difficulty: 5 },
            { name: 'Golden Fish', emoji: '‚ú®', value: 500, xp: 500, rarity: 5, minLine: 5, weight: 0.5, difficulty: 3 },
            { name: 'Sea Dragon', emoji: 'üêâ', value: 1000, xp: 1000, rarity: 5, minLine: 6, weight: 0.2, difficulty: 5 },
            { name: 'Old Boot', emoji: 'üë¢', value: 1, xp: 5, rarity: 1, minLine: 1, weight: 5, difficulty: 1 },
            { name: 'Treasure Chest', emoji: 'üíé', value: 200, xp: 100, rarity: 5, minLine: 1, weight: 0.3, difficulty: 2 },
        ];

        const nightFishTypes = [
            { name: 'Lanternfish', emoji: 'üî¶', value: 15, xp: 25, rarity: 1, minLine: 1, weight: 35, difficulty: 1, night: true },
            { name: 'Moonfish', emoji: 'üåô', value: 30, xp: 45, rarity: 2, minLine: 1, weight: 25, difficulty: 2, night: true },
            { name: 'Anglerfish', emoji: 'üê°', value: 60, xp: 90, rarity: 3, minLine: 2, weight: 12, difficulty: 4, night: true },
            { name: 'Ghost Fish', emoji: 'üëª', value: 80, xp: 120, rarity: 3, minLine: 2, weight: 8, difficulty: 3, night: true },
            { name: 'Vampire Squid', emoji: 'ü¶ë', value: 120, xp: 180, rarity: 4, minLine: 3, weight: 5, difficulty: 4, night: true },
            { name: 'Bioluminescent Jellyfish', emoji: 'üéê', value: 90, xp: 140, rarity: 4, minLine: 3, weight: 6, difficulty: 2, night: true },
            { name: 'Abyssal Serpent', emoji: 'üêç', value: 200, xp: 300, rarity: 5, minLine: 4, weight: 2, difficulty: 5, night: true },
            { name: 'Starlight Manta', emoji: '‚≠ê', value: 300, xp: 400, rarity: 5, minLine: 5, weight: 1, difficulty: 4, night: true },
            { name: 'Lunar Leviathan', emoji: 'üåï', value: 800, xp: 800, rarity: 5, minLine: 6, weight: 0.15, difficulty: 5, night: true },
            { name: 'Sunken Treasure', emoji: 'üè¥‚Äç‚ò†Ô∏è', value: 250, xp: 150, rarity: 5, minLine: 1, weight: 0.4, difficulty: 2, night: true },
        ];

        // Combine for collection display
        const allFishTypes = [...dayFishTypes, ...nightFishTypes];

        // Game State
        let gameState = {
            coins: 0,
            level: 1,
            xp: 0,
            xpNeeded: 100,
            totalFish: 0,
            upgrades: {
                rod: 1,
                bait: 1,
                line: 1,
                luck: 1
            },
            collection: {},
            state: 'idle', // idle, charging, casting, waiting, biting, reeling
            castPower: 0,
            bobber: { x: 0, y: 0, targetY: 0, visible: false },
            currentFish: null,
            biteTimer: 0,
            // Reeling mini-game state
            reelProgress: 0,
            tension: 50, // 0-100, want to keep in 30-70 range
            fishPull: 0,
            isReeling: false,
            reelDifficulty: 1,
            // Day/Night cycle
            timeOfDay: 0, // 0-1, 0 = noon, 0.5 = midnight
            dayLength: 180, // seconds for full day cycle (3 minutes)
            isNight: false,
            // Visual elements
            particles: [],
            bubbles: [],
            fishInWater: [],
            stars: []
        };

        // Generate stars once
        function generateStars() {
            gameState.stars = [];
            for (let i = 0; i < 100; i++) {
                gameState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.4,
                    size: Math.random() * 2 + 1,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }

        // Load saved game
        function loadGame() {
            const saved = localStorage.getItem('fishingFrenzy');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.coins = data.coins || 0;
                gameState.level = data.level || 1;
                gameState.xp = data.xp || 0;
                gameState.xpNeeded = data.xpNeeded || 100;
                gameState.totalFish = data.totalFish || 0;
                gameState.upgrades = data.upgrades || { rod: 1, bait: 1, line: 1, luck: 1 };
                gameState.collection = data.collection || {};
                gameState.timeOfDay = data.timeOfDay || 0;
            }
            gameState.state = 'idle';
            gameState.bobber.visible = false;
            gameState.particles = [];
            gameState.bubbles = [];
            gameState.fishInWater = [];
            generateStars();
        }

        function saveGame() {
            const saveData = {
                coins: gameState.coins,
                level: gameState.level,
                xp: gameState.xp,
                xpNeeded: gameState.xpNeeded,
                totalFish: gameState.totalFish,
                upgrades: gameState.upgrades,
                collection: gameState.collection,
                timeOfDay: gameState.timeOfDay
            };
            localStorage.setItem('fishingFrenzy', JSON.stringify(saveData));
        }

        // UI Updates
        function updateUI() {
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('xp').textContent = gameState.xp;
            document.getElementById('xpNeeded').textContent = gameState.xpNeeded;
            document.getElementById('totalFish').textContent = gameState.totalFish;
            document.getElementById('rodLevel').textContent = gameState.upgrades.rod;
            document.getElementById('baitLevel').textContent = gameState.upgrades.bait;
            document.getElementById('lineLevel').textContent = gameState.upgrades.line;
            document.getElementById('luckLevel').textContent = gameState.upgrades.luck;

            // Update rod display
            const rod = getCurrentRod();
            document.getElementById('rodName').textContent = rod.name;
            const rodIcon = document.getElementById('rodIcon');
            rodIcon.style.background = `linear-gradient(90deg, ${rod.gradient[0]}, ${rod.gradient[1]})`;
            if (rod.sparkle) {
                rodIcon.style.boxShadow = '0 0 10px #00FFFF, 0 0 20px #00FFFF';
            } else {
                rodIcon.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
            }

            const rodCost = 100 * Math.pow(2, gameState.upgrades.rod - 1);
            const baitCost = 150 * Math.pow(2, gameState.upgrades.bait - 1);
            const lineCost = 200 * Math.pow(2, gameState.upgrades.line - 1);
            const luckCost = 250 * Math.pow(2, gameState.upgrades.luck - 1);

            document.getElementById('buyRod').textContent = gameState.upgrades.rod >= 10 ? 'MAX' : `${rodCost} ü™ô`;
            document.getElementById('buyBait').textContent = gameState.upgrades.bait >= 10 ? 'MAX' : `${baitCost} ü™ô`;
            document.getElementById('buyLine').textContent = gameState.upgrades.line >= 10 ? 'MAX' : `${lineCost} ü™ô`;
            document.getElementById('buyLuck').textContent = gameState.upgrades.luck >= 10 ? 'MAX' : `${luckCost} ü™ô`;

            document.getElementById('buyRod').disabled = gameState.coins < rodCost || gameState.upgrades.rod >= 10;
            document.getElementById('buyBait').disabled = gameState.coins < baitCost || gameState.upgrades.bait >= 10;
            document.getElementById('buyLine').disabled = gameState.coins < lineCost || gameState.upgrades.line >= 10;
            document.getElementById('buyLuck').disabled = gameState.coins < luckCost || gameState.upgrades.luck >= 10;

            // Update time indicator
            const timeEl = document.getElementById('timeIndicator');
            if (gameState.isNight) {
                timeEl.textContent = 'üåô Night';
            } else {
                timeEl.textContent = '‚òÄÔ∏è Day';
            }
        }

        function showMessage(text, duration = 2000) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, duration);
        }

        function createFloatingText(x, y, text, className = 'fish-caught') {
            const el = document.createElement('div');
            el.className = className;
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(el);
            setTimeout(() => el.remove(), 2000);
        }

        // Game Logic
        function selectFish() {
            const baitBonus = gameState.upgrades.bait;
            const lineLevel = gameState.upgrades.line;
            const luckBonus = gameState.upgrades.luck;

            // Select fish pool based on time
            const fishPool = gameState.isNight ? nightFishTypes : dayFishTypes;

            // Filter fish by line level and calculate weights
            const available = fishPool.filter(f => f.minLine <= lineLevel);
            let weights = available.map(f => {
                let w = f.weight;
                // Bait increases rare fish chance
                if (f.rarity >= 3) w *= (1 + baitBonus * 0.3);
                // Luck affects treasure and special items
                if (f.name.includes('Treasure') || f.name.includes('Golden') || f.name.includes('Sunken')) {
                    w *= (1 + luckBonus * 0.5);
                }
                return w;
            });

            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;

            for (let i = 0; i < available.length; i++) {
                random -= weights[i];
                if (random <= 0) return available[i];
            }
            return available[0];
        }

        function addXP(amount) {
            gameState.xp += amount;
            while (gameState.xp >= gameState.xpNeeded) {
                gameState.xp -= gameState.xpNeeded;
                gameState.level++;
                gameState.xpNeeded = Math.floor(100 * Math.pow(1.5, gameState.level - 1));
                showMessage(`üéâ LEVEL UP! Level ${gameState.level}!`, 3000);
                playLevelUpSound();
                // Bonus coins on level up
                const bonus = gameState.level * 50;
                gameState.coins += bonus;
                createFloatingText(canvas.width / 2, canvas.height / 2 - 50, `+${bonus} ü™ô Bonus!`, 'coin-popup');
            }
        }

        function catchFish(fish) {
            const luckBonus = 1 + gameState.upgrades.luck * 0.1;
            const coins = Math.floor(fish.value * luckBonus * (0.8 + Math.random() * 0.4));

            gameState.coins += coins;
            gameState.totalFish++;
            addXP(fish.xp);

            // Add to collection
            if (!gameState.collection[fish.name]) {
                gameState.collection[fish.name] = 0;
                showMessage(`üìñ New Discovery: ${fish.emoji} ${fish.name}!`, 3000);
            }
            gameState.collection[fish.name]++;

            createFloatingText(gameState.bobber.x, gameState.bobber.y - 30, fish.emoji);
            createFloatingText(gameState.bobber.x + 30, gameState.bobber.y, `+${coins}`, 'coin-popup');

            playCatchSound(fish.value);
            saveGame();
            updateUI();
        }

        function loseFish() {
            gameState.state = 'idle';
            gameState.bobber.visible = false;
            gameState.reelProgress = 0;
            gameState.isReeling = false;
            document.getElementById('reelGame').style.display = 'none';
            showMessage(`üíî The ${gameState.currentFish.emoji} ${gameState.currentFish.name} got away!`);
            playSnapSound();
            document.getElementById('instructions').textContent = 'Hold SPACE or CLICK to charge cast, release to fish!';
        }

        // Particles
        function createSplash(x, y) {
            for (let i = 0; i < 15; i++) {
                gameState.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 8 - 2,
                    life: 1,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function createBubbles(x, y) {
            for (let i = 0; i < 5; i++) {
                gameState.bubbles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + Math.random() * 20,
                    vy: -Math.random() * 2 - 1,
                    size: Math.random() * 6 + 3,
                    life: 1
                });
            }
        }

        // Swimming fish in background
        function spawnBackgroundFish() {
            if (gameState.fishInWater.length < 10 && Math.random() < 0.02) {
                const waterTop = canvas.height * 0.45;
                const isNightFish = gameState.isNight;
                gameState.fishInWater.push({
                    x: Math.random() < 0.5 ? -50 : canvas.width + 50,
                    y: waterTop + Math.random() * (canvas.height - waterTop - 50),
                    speed: (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1),
                    size: Math.random() * 20 + 15,
                    color: isNightFish
                        ? `hsl(${Math.random() * 60 + 260}, 70%, 60%)` // Purple/blue for night
                        : `hsl(${Math.random() * 60 + 180}, 70%, 50%)`, // Blue/green for day
                    glow: isNightFish
                });
            }
        }

        // Input Handling
        let isCharging = false;

        function startCast() {
            if (gameState.state !== 'idle') return;
            initAudio();
            isCharging = true;
            gameState.state = 'charging';
            gameState.castPower = 0;
            document.getElementById('castPower').style.display = 'block';
        }

        function releaseCast() {
            if (gameState.state !== 'charging') return;
            isCharging = false;
            document.getElementById('castPower').style.display = 'none';

            if (gameState.castPower < 10) {
                gameState.state = 'idle';
                return;
            }

            gameState.state = 'casting';
            playCastSound();

            // Calculate bobber target
            const power = gameState.castPower / 100;
            const waterTop = canvas.height * 0.45;
            const maxDistance = canvas.height * 0.4;

            gameState.bobber = {
                x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                y: canvas.height * 0.3,
                targetY: waterTop + power * maxDistance,
                visible: true,
                vy: 0
            };

            document.getElementById('instructions').textContent = 'Casting...';
        }

        function startReeling() {
            if (gameState.state === 'reeling') {
                gameState.isReeling = true;
            }
        }

        function stopReeling() {
            gameState.isReeling = false;
        }

        canvas.addEventListener('mousedown', (e) => {
            if (gameState.state === 'idle') {
                startCast();
            } else if (gameState.state === 'biting') {
                attemptCatch();
            } else if (gameState.state === 'reeling') {
                startReeling();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            releaseCast();
            stopReeling();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.state === 'idle') {
                startCast();
            } else if (gameState.state === 'biting') {
                attemptCatch();
            } else if (gameState.state === 'reeling') {
                startReeling();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            releaseCast();
            stopReeling();
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                if (gameState.state === 'biting') {
                    attemptCatch();
                } else if (gameState.state === 'reeling') {
                    startReeling();
                } else if (gameState.state === 'idle') {
                    startCast();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                releaseCast();
                stopReeling();
            }
        });

        function attemptCatch() {
            if (gameState.state !== 'biting') return;

            // Start reeling mini-game
            gameState.state = 'reeling';
            gameState.tension = 50;
            gameState.reelProgress = 0;
            gameState.fishPull = 0;
            gameState.isReeling = false;

            // Difficulty based on fish
            const baseDifficulty = gameState.currentFish.difficulty || 1;
            const lineBonus = gameState.upgrades.line * 0.1; // Line makes it easier
            gameState.reelDifficulty = Math.max(0.5, baseDifficulty - lineBonus);

            document.getElementById('reelGame').style.display = 'block';
            document.getElementById('instructions').textContent = 'Hold SPACE/Click to reel! Keep marker in GREEN zone!';
        }

        // Shop
        document.getElementById('shopBtn').addEventListener('click', () => {
            document.getElementById('shop').style.display = 'block';
        });

        document.getElementById('closeShop').addEventListener('click', () => {
            document.getElementById('shop').style.display = 'none';
        });

        function buyUpgrade(type, baseCost) {
            const cost = baseCost * Math.pow(2, gameState.upgrades[type] - 1);
            if (gameState.coins >= cost && gameState.upgrades[type] < 10) {
                gameState.coins -= cost;
                gameState.upgrades[type]++;
                playSound(600, 0.1, 'sine');
                playSound(800, 0.1, 'sine');

                // Show rod upgrade message
                if (type === 'rod') {
                    const newRod = getCurrentRod();
                    showMessage(`üé£ Upgraded to ${newRod.name} Rod!`, 2500);
                }

                saveGame();
                updateUI();
            }
        }

        document.getElementById('buyRod').addEventListener('click', () => buyUpgrade('rod', 100));
        document.getElementById('buyBait').addEventListener('click', () => buyUpgrade('bait', 150));
        document.getElementById('buyLine').addEventListener('click', () => buyUpgrade('line', 200));
        document.getElementById('buyLuck').addEventListener('click', () => buyUpgrade('luck', 250));

        // Collection
        document.getElementById('collectionBtn').addEventListener('click', () => {
            updateCollection();
            document.getElementById('collection').style.display = 'block';
        });

        document.getElementById('closeCollection').addEventListener('click', () => {
            document.getElementById('collection').style.display = 'none';
        });

        function updateCollection() {
            const list = document.getElementById('fishList');
            list.innerHTML = '';

            // Day fish header
            const dayHeader = document.createElement('h3');
            dayHeader.textContent = '‚òÄÔ∏è Day Fish';
            dayHeader.style.color = '#f39c12';
            dayHeader.style.marginTop = '10px';
            list.appendChild(dayHeader);

            dayFishTypes.forEach(fish => {
                const count = gameState.collection[fish.name] || 0;
                const div = document.createElement('div');
                div.className = 'fish-entry' + (count === 0 ? ' locked' : '');
                div.innerHTML = `
                    <span class="fish-icon">${count > 0 ? fish.emoji : '‚ùì'}</span>
                    <div>
                        <strong>${count > 0 ? fish.name : '???'}</strong><br>
                        <small>Caught: ${count} | Value: ${fish.value} ü™ô | Difficulty: ${'‚≠ê'.repeat(fish.difficulty)}</small>
                    </div>
                `;
                list.appendChild(div);
            });

            // Night fish header
            const nightHeader = document.createElement('h3');
            nightHeader.textContent = 'üåô Night Fish';
            nightHeader.style.color = '#9b59b6';
            nightHeader.style.marginTop = '20px';
            list.appendChild(nightHeader);

            nightFishTypes.forEach(fish => {
                const count = gameState.collection[fish.name] || 0;
                const div = document.createElement('div');
                div.className = 'fish-entry night-fish' + (count === 0 ? ' locked' : '');
                div.innerHTML = `
                    <span class="fish-icon">${count > 0 ? fish.emoji : '‚ùì'}</span>
                    <div>
                        <strong>${count > 0 ? fish.name : '???'}</strong><br>
                        <small>Caught: ${count} | Value: ${fish.value} ü™ô | Difficulty: ${'‚≠ê'.repeat(fish.difficulty)}</small>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        // Game Loop
        function update(dt) {
            // Update day/night cycle
            gameState.timeOfDay += dt / gameState.dayLength;
            if (gameState.timeOfDay >= 1) gameState.timeOfDay -= 1;

            const wasNight = gameState.isNight;
            gameState.isNight = gameState.timeOfDay > 0.25 && gameState.timeOfDay < 0.75;

            // Notify on time change
            if (wasNight !== gameState.isNight) {
                if (gameState.isNight) {
                    showMessage('üåô Night has fallen... New fish appear!', 3000);
                } else {
                    showMessage('‚òÄÔ∏è The sun rises... Day fish return!', 3000);
                }
                updateUI();
            }

            // Charging
            if (gameState.state === 'charging') {
                gameState.castPower = Math.min(100, gameState.castPower + dt * 80);
                document.getElementById('castPowerFill').style.width = gameState.castPower + '%';
            }

            // Casting animation
            if (gameState.state === 'casting') {
                gameState.bobber.vy += 15 * dt;
                gameState.bobber.y += gameState.bobber.vy;

                if (gameState.bobber.y >= gameState.bobber.targetY) {
                    gameState.bobber.y = gameState.bobber.targetY;
                    gameState.state = 'waiting';
                    createSplash(gameState.bobber.x, gameState.bobber.y);
                    playSplashSound();

                    // Set bite timer based on rod level
                    const baseWait = 3 - gameState.upgrades.rod * 0.2;
                    gameState.biteTimer = baseWait + Math.random() * 3;
                    gameState.currentFish = selectFish();

                    document.getElementById('instructions').textContent = 'Waiting for a bite...';
                }
            }

            // Waiting for bite
            if (gameState.state === 'waiting') {
                gameState.biteTimer -= dt;

                // Bobber bobbing animation
                gameState.bobber.y = gameState.bobber.targetY + Math.sin(Date.now() / 300) * 3;

                // Random bubbles
                if (Math.random() < 0.05) {
                    createBubbles(gameState.bobber.x, gameState.bobber.y);
                }

                if (gameState.biteTimer <= 0) {
                    gameState.state = 'biting';
                    gameState.biteTimer = 2 + gameState.upgrades.rod * 0.3; // Time to react
                    playBiteSound();
                    document.getElementById('instructions').textContent = 'üêü FISH ON! Click or press SPACE!';
                }
            }

            // Biting - player must react
            if (gameState.state === 'biting') {
                gameState.biteTimer -= dt;

                // Aggressive bobber movement
                gameState.bobber.y = gameState.bobber.targetY + Math.sin(Date.now() / 50) * 10;
                gameState.bobber.x += Math.sin(Date.now() / 80) * 2;

                createBubbles(gameState.bobber.x, gameState.bobber.y);

                if (gameState.biteTimer <= 0) {
                    // Fish got away
                    gameState.state = 'idle';
                    gameState.bobber.visible = false;
                    showMessage('Too slow! The fish got away! üêüüí®');
                    playMissSound();
                    document.getElementById('instructions').textContent = 'Hold SPACE or CLICK to charge cast, release to fish!';
                }
            }

            // Reeling mini-game
            if (gameState.state === 'reeling') {
                // Fish pulls the tension up randomly
                const pullStrength = gameState.reelDifficulty * 30;
                const pullVariation = Math.sin(Date.now() / (300 / gameState.reelDifficulty)) * pullStrength;
                const randomJerk = Math.random() < 0.02 ? (Math.random() - 0.5) * 40 * gameState.reelDifficulty : 0;

                gameState.fishPull = pullVariation + randomJerk;

                // Tension mechanics
                if (gameState.isReeling) {
                    // Reeling decreases tension (pulls line in)
                    gameState.tension -= dt * 60;
                    // Progress increases when reeling in green zone
                    if (gameState.tension >= 20 && gameState.tension <= 80) {
                        gameState.reelProgress += dt * (25 / gameState.reelDifficulty);
                        playReelSound();
                    }
                } else {
                    // Not reeling - tension increases (fish pulls away)
                    gameState.tension += dt * 40 * gameState.reelDifficulty;
                }

                // Apply fish pull
                gameState.tension += gameState.fishPull * dt;

                // Clamp and check failure
                if (gameState.tension < 0) {
                    // Line went slack - fish escaped!
                    loseFish();
                    return;
                }
                if (gameState.tension > 100) {
                    // Line snapped!
                    loseFish();
                    return;
                }

                // Update UI
                document.getElementById('tensionMarker').style.left = gameState.tension + '%';
                document.getElementById('reelProgressFill').style.width = gameState.reelProgress + '%';

                // Update struggle text
                const struggleEl = document.getElementById('fishStruggle');
                if (Math.abs(gameState.fishPull) > 20) {
                    struggleEl.textContent = '‚ö†Ô∏è The fish is fighting hard!';
                    struggleEl.style.color = '#e74c3c';
                } else if (Math.abs(gameState.fishPull) > 10) {
                    struggleEl.textContent = 'üêü The fish is struggling...';
                    struggleEl.style.color = '#f39c12';
                } else {
                    struggleEl.textContent = '‚ú® The fish is calm...';
                    struggleEl.style.color = '#2ecc71';
                }

                // Check win
                if (gameState.reelProgress >= 100) {
                    document.getElementById('reelGame').style.display = 'none';
                    catchFish(gameState.currentFish);
                    gameState.state = 'idle';
                    gameState.bobber.visible = false;
                    gameState.reelProgress = 0;
                    gameState.isReeling = false;
                    document.getElementById('instructions').textContent = 'Hold SPACE or CLICK to charge cast, release to fish!';
                }

                // Bobber movement during reeling
                gameState.bobber.y = gameState.bobber.targetY - (gameState.reelProgress / 100) * (gameState.bobber.targetY - canvas.height * 0.35);
                gameState.bobber.x += Math.sin(Date.now() / 100) * 2;
            }

            // Update particles
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= dt * 2;
                return p.life > 0;
            });

            // Update bubbles
            gameState.bubbles = gameState.bubbles.filter(b => {
                b.y += b.vy;
                b.life -= dt;
                return b.life > 0 && b.y > canvas.height * 0.4;
            });

            // Update background fish
            spawnBackgroundFish();
            gameState.fishInWater = gameState.fishInWater.filter(f => {
                f.x += f.speed;
                return f.x > -100 && f.x < canvas.width + 100;
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const waterTop = canvas.height * 0.45;

            // Calculate day/night interpolation
            // 0 = noon (brightest), 0.5 = midnight (darkest)
            let nightAmount;
            if (gameState.timeOfDay < 0.25) {
                nightAmount = 1 - (gameState.timeOfDay / 0.25); // Dawn
            } else if (gameState.timeOfDay < 0.5) {
                nightAmount = (gameState.timeOfDay - 0.25) / 0.25; // Dusk approaching midnight
            } else if (gameState.timeOfDay < 0.75) {
                nightAmount = 1 - (gameState.timeOfDay - 0.5) / 0.25; // After midnight
            } else {
                nightAmount = (gameState.timeOfDay - 0.75) / 0.25; // Evening
            }
            nightAmount = Math.max(0, Math.min(1, nightAmount));

            // Sky colors interpolated
            const daySkyTop = [135, 206, 235]; // #87CEEB
            const daySkyBottom = [74, 144, 217]; // #4A90D9
            const nightSkyTop = [10, 10, 35];
            const nightSkyBottom = [25, 25, 60];

            const skyTopColor = interpolateColor(daySkyTop, nightSkyTop, nightAmount);
            const skyBottomColor = interpolateColor(daySkyBottom, nightSkyBottom, nightAmount);

            // Sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, waterTop);
            skyGrad.addColorStop(0, `rgb(${skyTopColor.join(',')})`);
            skyGrad.addColorStop(1, `rgb(${skyBottomColor.join(',')})`);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, waterTop);

            // Stars (only at night)
            if (nightAmount > 0.3) {
                const starAlpha = (nightAmount - 0.3) / 0.7;
                gameState.stars.forEach(star => {
                    const twinkle = Math.sin(Date.now() / 500 + star.twinkle) * 0.3 + 0.7;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${starAlpha * twinkle})`;
                    ctx.fill();
                });
            }

            // Sun or Moon
            if (nightAmount < 0.5) {
                // Sun
                const sunAlpha = 1 - nightAmount * 2;
                ctx.beginPath();
                ctx.arc(canvas.width - 100, 80, 50, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${sunAlpha})`;
                ctx.fill();
                // Sun glow
                const sunGlow = ctx.createRadialGradient(canvas.width - 100, 80, 30, canvas.width - 100, 80, 80);
                sunGlow.addColorStop(0, `rgba(255, 200, 50, ${sunAlpha * 0.3})`);
                sunGlow.addColorStop(1, 'rgba(255, 200, 50, 0)');
                ctx.fillStyle = sunGlow;
                ctx.fillRect(canvas.width - 200, 0, 200, 180);
            }
            if (nightAmount > 0.3) {
                // Moon
                const moonAlpha = (nightAmount - 0.3) / 0.7;
                ctx.beginPath();
                ctx.arc(canvas.width - 100, 80, 40, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(240, 240, 220, ${moonAlpha})`;
                ctx.fill();
                // Moon craters
                ctx.beginPath();
                ctx.arc(canvas.width - 90, 70, 8, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 200, 180, ${moonAlpha * 0.5})`;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(canvas.width - 115, 90, 6, 0, Math.PI * 2);
                ctx.fill();
                // Moon glow
                const moonGlow = ctx.createRadialGradient(canvas.width - 100, 80, 30, canvas.width - 100, 80, 100);
                moonGlow.addColorStop(0, `rgba(200, 200, 255, ${moonAlpha * 0.2})`);
                moonGlow.addColorStop(1, 'rgba(200, 200, 255, 0)');
                ctx.fillStyle = moonGlow;
                ctx.fillRect(canvas.width - 220, 0, 240, 200);
            }

            // Clouds (dimmer at night)
            const cloudAlpha = 0.8 - nightAmount * 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${cloudAlpha})`;
            drawCloud(100, 60, 1);
            drawCloud(300, 100, 0.7);
            drawCloud(canvas.width - 300, 120, 0.8);

            // Water colors
            const dayWaterTop = [30, 144, 255];
            const dayWaterMid = [0, 105, 148];
            const dayWaterBottom = [0, 51, 102];
            const nightWaterTop = [20, 50, 100];
            const nightWaterMid = [10, 30, 60];
            const nightWaterBottom = [5, 15, 40];

            const waterTopColor = interpolateColor(dayWaterTop, nightWaterTop, nightAmount);
            const waterMidColor = interpolateColor(dayWaterMid, nightWaterMid, nightAmount);
            const waterBottomColor = interpolateColor(dayWaterBottom, nightWaterBottom, nightAmount);

            // Water gradient
            const waterGrad = ctx.createLinearGradient(0, waterTop, 0, canvas.height);
            waterGrad.addColorStop(0, `rgb(${waterTopColor.join(',')})`);
            waterGrad.addColorStop(0.5, `rgb(${waterMidColor.join(',')})`);
            waterGrad.addColorStop(1, `rgb(${waterBottomColor.join(',')})`);
            ctx.fillStyle = waterGrad;
            ctx.fillRect(0, waterTop, canvas.width, canvas.height - waterTop);

            // Water surface wave
            ctx.beginPath();
            ctx.moveTo(0, waterTop);
            for (let x = 0; x <= canvas.width; x += 20) {
                ctx.lineTo(x, waterTop + Math.sin((x + Date.now() / 500) / 30) * 5);
            }
            ctx.lineTo(canvas.width, waterTop + 20);
            ctx.lineTo(0, waterTop + 20);
            ctx.closePath();
            ctx.fillStyle = `rgba(255, 255, 255, ${0.2 - nightAmount * 0.1})`;
            ctx.fill();

            // Draw background fish
            gameState.fishInWater.forEach(f => {
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.scale(f.speed > 0 ? 1 : -1, 1);

                // Glow effect for night fish
                if (f.glow && nightAmount > 0.3) {
                    ctx.shadowColor = f.color;
                    ctx.shadowBlur = 15;
                }

                ctx.fillStyle = f.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-f.size, 0);
                ctx.lineTo(-f.size - 10, -8);
                ctx.lineTo(-f.size - 10, 8);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });

            // Draw dock/pier
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(canvas.width / 2 - 60, waterTop - 20, 120, 25);
            ctx.fillStyle = '#654321';
            ctx.fillRect(canvas.width / 2 - 50, waterTop, 20, 60);
            ctx.fillRect(canvas.width / 2 + 30, waterTop, 20, 60);

            // Draw fishing rod with current rod type
            if (gameState.bobber.visible || gameState.state === 'charging') {
                const rod = getCurrentRod();

                // Rod shadow
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 + 2, waterTop - 13);
                ctx.quadraticCurveTo(
                    canvas.width / 2 + 52,
                    waterTop - 98,
                    canvas.width / 2 + 32,
                    canvas.height * 0.25 + 2
                );
                ctx.stroke();

                // Rod gradient
                const rodGrad = ctx.createLinearGradient(
                    canvas.width / 2, waterTop - 15,
                    canvas.width / 2 + 30, canvas.height * 0.25
                );
                rodGrad.addColorStop(0, rod.gradient[0]);
                rodGrad.addColorStop(1, rod.gradient[1]);

                ctx.strokeStyle = rodGrad;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';

                // Diamond rod sparkle effect
                if (rod.sparkle) {
                    ctx.shadowColor = '#00FFFF';
                    ctx.shadowBlur = 10;
                }

                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, waterTop - 15);
                ctx.quadraticCurveTo(
                    canvas.width / 2 + 50,
                    waterTop - 100,
                    canvas.width / 2 + 30,
                    canvas.height * 0.25
                );
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Fishing line
                if (gameState.bobber.visible) {
                    ctx.strokeStyle = gameState.isNight ? 'rgba(200,200,255,0.6)' : '#AAA';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 + 30, canvas.height * 0.25);
                    ctx.lineTo(gameState.bobber.x, gameState.bobber.y);
                    ctx.stroke();
                }
            }

            // Draw bobber
            if (gameState.bobber.visible) {
                // Bobber glow at night
                if (gameState.isNight) {
                    ctx.shadowColor = '#FF6B6B';
                    ctx.shadowBlur = 10;
                }

                ctx.beginPath();
                ctx.arc(gameState.bobber.x, gameState.bobber.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = gameState.state === 'biting' ? '#FF0000' : '#FF6B6B';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(gameState.bobber.x, gameState.bobber.y - 5, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();

                ctx.shadowBlur = 0;

                // Exclamation when biting
                if (gameState.state === 'biting') {
                    ctx.font = 'bold 30px Arial';
                    ctx.fillStyle = '#FF0000';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', gameState.bobber.x, gameState.bobber.y - 30);
                }

                // Show fish emoji during reeling
                if (gameState.state === 'reeling' && gameState.currentFish) {
                    ctx.font = '24px Arial';
                    ctx.fillText(gameState.currentFish.emoji, gameState.bobber.x, gameState.bobber.y + 35);
                }
            }

            // Draw bubbles
            gameState.bubbles.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${b.life * 0.5})`;
                ctx.fill();
            });

            // Draw splash particles
            gameState.particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
                ctx.fill();
            });
        }

        function interpolateColor(c1, c2, t) {
            return [
                Math.round(c1[0] + (c2[0] - c1[0]) * t),
                Math.round(c1[1] + (c2[1] - c1[1]) * t),
                Math.round(c1[2] + (c2[2] - c1[2]) * t)
            ];
        }

        function drawCloud(x, y, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.arc(35, 0, 35, 0, Math.PI * 2);
            ctx.arc(70, 0, 30, 0, Math.PI * 2);
            ctx.arc(20, -20, 25, 0, Math.PI * 2);
            ctx.arc(50, -20, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Initialize
        loadGame();
        updateUI();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
